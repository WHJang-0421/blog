---
title:  "인터프리터 4: 객체지향"
author: "Woohyuk Jang"
draft: false

date: "2023-09-17"
description: ""
categories:
  - cs/compilers
tags:
  - Blog
---
### 인터프리터 #4: 객체지향



*이 블로그 포스트는&#x20;*[*Crafting Interpreters*](https://craftinginterpreters.com/)*를 읽은 후 정리한 글이다. 구현은&#x20;*[*여기*](https://github.com/WHJang-0421/make-interpreters)*에 했으며 책의 코드를 그대로 따라했다.*



OOP(Object Oriented Programming)만큼 널리 쓰이는 프로그래밍 패러다임도 없을 것이다. OOP가 어떻게 구현되는지 궁금하지 않은가?



1. OOP란?



이 글은 OOP 수업이 아니기 때문에, 기능만 간단히 훑는다. OOP는 class, [prototype](https://en.wikipedia.org/wiki/Prototype-based_programming), [multimethod](https://en.wikipedia.org/wiki/Multiple_dispatch)를 이용하여 구현한다. 여기서는 class를 구현한다:



* Constructor: 객체를 만들고 초기화한다.

* Field: 객체의 데이터

* Methods: 모든 객체가 공유하는, 각각의 field와 상호작용하는 함수

* Inheritance: 상속을 통해 코드를 재사용한다.



2\. 순서



* class에는 메서드를, instance에는 field와 클래스를 저장한다.



순서:



A. 클래스 정의 (환경에서 클래스명과 런타임 클래스 객체를 연결짓는다)



B. 객체 생성 (이 책에서는 클래스를 호출하는 것으로 해결. 역시 인스턴스를 나타내는 런타임 객체가 필요하다)



C. field 호출 (get expression과 set expression을 구현해야 한다. 런타임 인스턴스 객체에 get과 set을 정의하면 된다.)



D. 메서드 호출과 this 키워드 (closure와 비슷하다. 메서드 정의 시에 this를 변수로 가지고 외부에 인스턴스의 클로져가 있는 환경이 메서드의 클로져가 된다.)



E. constructor와 initializer: 사실 빈 객체는 이미 B에서 만들어졌다. lox와 같은 다이나믹 언어에서 정의하는 것은 initializer 뿐이다. 여기서는 init을 해당 객체를 반환하는 특별한 함수로 정의했다.



F: Inheritance: super가 this의 부모가 아니라 정의된 클래스의 부모라는 점에 유의해야 한다. 이를 위해서 bound method 스코프 위에 superclass를 포함하는 스코프를 추가해야 한다. 이 점을 제외하면 메서드와 클래스 구현과 비슷하다.



3\. 소감



직접 dynamic type 언어의 tree-walk interpreter를 만들어 보니 재미있었다. 만들면서 내가 프로그래밍 언어에 대해 잘 모르고 있다는 점을 느꼈다. 프로그래밍 언어에 대해서 더 잘 알아보고 싶다는 생각이 들었다.



By [Woohyuk Jang](https://medium.com/@morrranii) on [September 17, 2023](https://medium.com/p/895ec4542420).

Exported from [Medium](https://medium.com) on August 26, 2025.
