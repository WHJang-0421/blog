---
title:  "알고리즘 2: 시작하기"
author: "Woohyuk Jang"
draft: false

date: "2023-02-25"
description: ""
categories:
  - cs
tags:
  - Blog
---
### 알고리즘 #2: 시작하기



### 2.1 삽입정렬



#### 정렬 문제의 정의



* 입력: n개 수의 수열 (a1 \~ an)

* 출력: a’1 ≤ a’2 ≤ … ≤ a’n을 만족하는 입력 수열의 재배치 (a’1 \~ a’n)



#### 삽입 정렬



* 삽입 정렬은 작은 n값에 어울린다.

* 책에서 의사코드로 제시한 내용을 C++로 바꿔 풀어보려 한다. 오랜만에 C++을 건드리니 좀 헷갈린다.



```

#include <iostream>

#include <vector>



using namespace std;



void InsertionSort(vector<int>& array);

void printArray(vector<int> array);



int main() {

    vector<int> array = {7, 8, 9, 5, 4, 3, 2};

    cout << "Initial array: " << "\n";

    printArray(array);

    InsertionSort(array);

    cout << "Sorted array: " << "\n";

    printArray(array);

}



void InsertionSort(vector<int>& array) {

    for (int i = 1; i < array.size(); i++) {

        int element = array[i];

        int j = i - 1;

        while (j >= 0 && array[j] > element) {

            array[j+1] = array[j];

            j--;

        }

        array[j+1] = element;

    }

}



void printArray(vector<int> array) {

    for (int elem: array) {

        cout << elem << " ";

    }

    cout << "\n";

}

```



#### 루프 불변성과 삽입 정렬의 타당성



*루프 불변성 (Loop Invariant)*&#xB294; 루프에서 항상 일정한 성질이다. 위의 삽입 정렬 예시에서 루프 불변성은 `array[0]부터 array[i-1]까지의 값은 정렬되어 있다` 는 사실이다. 루프 불변성을 통해 삽입 정렬의 타당성을 증명할 수 있다:



* 초기 조건: 루프 불변성이 루프 돌리기 전에 참이다. `array[0] 값 하나가 정렬되어 있다` 가 참이므로 초기 조건이 만족된다.

* 유지 조건: 루프 반복 시작 전 루프 불변성이 참이라면, 루프 반복 후에도 루프 불변성이 참이다. `반복 전 루프 불변성이 참이라면, 새 배열에서 array[0]~array[j-1], array[j+1]~array[i]가 정렬되어 있으므로, 반복 후에도 역시 루프 불변성이 성립한다.`

* 종료 조건: 루프 종료 후 루프 불변성이 알고리즘의 타당성을 보여준다. `루프 불변성이 배열이 정렬되어 있음을 보여준다.`



#### 연습문제



2: 수열을 오름차순 대신 내림차순으로 정렬하도록 InsertionSort 함수를 재작성하라.



* line 22에서 `array[j] > element` 를 `array[j] < element` 로 바꾸면 된다.



3: 다음의 검색 문제를 생각해보자.



* 입력: n개의 수 a1\~an과 어떤 값 v

* 출력: ai = v인 인덱스 값 i. v가 배열 a에 존재하지 않으면 특수값 NIL.



선형 검색 코드를 작성하라.



```

#include <iostream>

#include <vector>



#define NIL (-1) // NIL을 -1로 설정했다.

using namespace std;



int linearSearch(vector<int> array, int v);

void printArray(const vector<int>& array);



int main() {

    vector<int> array = {7, 8, 9, 5, 4, 3, 2};

    int v = 3;

    int noExist = 11;



    cout << "array: ";

    printArray(array);



    cout << "v: " << v << "\n";

    cout << "LinearSearch(array, v): " << linearSearch(array, v) << "\n";



    cout << "v: " << noExist << "\n";

    cout << "LinearSearch(array, v): " << linearSearch(array, noExist) << "\n";

}



int linearSearch(vector<int> array, int v) {

    for (int i = 0; i < array.size(); i++) {

        if (array[i] == v) {

            return i;

        }

    }

    return NIL;

}



void printArray(const vector<int>& array) {

    for (int elem: array) {

        cout << elem << " ";

    }

    cout << "\n";

}

```



루프 불변성을 이용해 알고리즘의 타당성을 증명하라.



증명하려는 루프 불변성은 `array[0]~array[i-1] 중에 v가 없다` 이다.



* 초기 조건: 처음에 i=0이므로 `array[0]~array[i-1]` 는 공집합이다.

* 유지 조건: 이건 유지 조건이므로 `array[i] != v` 를 가정할 수 있다. 그러면 당연히 성립.

* 종료 조건: `array[i] = v` 여서 종료된 경우: 선형 검색이 의도대로 되었다. (이때는 설정한 루프 불변성이 성립하지 않지만, 알고리즘은 여전히 타당하다) `i == array.size()` 여서 종료된 경우: `array[i] != v` 를 가정할 수 있으므로, 루프 불변성에 의해 `array 중에 v가 없다.` 따라서 NIL 반환이 타당하다.



4: 원소가 n개인 두 배열 A,B에 저장된 두개의 n비트 이진수를 더하는 문제를 고려해 보자. 두 이진수의 합은 원소가 n+1개인 배열 C에 이진수 형태로 저장되어야 한다. 이 문제를 엄밀하게 서술하고 두 정수의 합을 구하는 의사코드를 작성하라.



* 문제의 엄밀한 서술 (이 이상 어떻게 더 엄밀하게 할지 모르겠다)



입력: 수열 A(a1\~an), 수열 B(b1\~bn). A,B는 0 또는 1로 구성된 길이1의 수열.



출력: 길이 n+1의 수열 C(c1\~cn+1). C 역시 0 또는 1로 구성. C에는 A와 B의 이진수 합이 저장되어 있어야 한다.



* 의사코드



```

procedure add(A, B):

  carry = 0

  for i=0 to A.length:

    digit = a ^ b ^ carry

    carry = a & b & carry

    add digit as first element of C

  add carry as first element of C

```



* C++ 코드



```

#include <iostream>

#include <deque>



using namespace std;



deque<int> addBits(const deque<int>& A, const deque<int>& B);

int numericValue(deque<int> array);

void printNum(const deque<int>& array, const string& name);



int main() {

    deque<int> A = {1, 0, 0, 1, 1, 0, 1}; // 1 + 4 + 8 + 64 = 77

    deque<int> B = {0, 1, 1, 1, 0, 1, 1}; // 1 + 2 + 8 + 16 + 32 = 59

    deque<int> C = addBits(A, B);



    printNum(A, "A");

    printNum(B, "B");

    printNum(C, "C");

    cout << "A: " << numericValue(A) << " B: " << numericValue(B) << " C: " << numericValue(C);

}



deque<int> addBits(const deque<int>& A, const deque<int>& B) {

    deque<int> C;

    int carry = 0;

    int digit;

    for (int i = A.size()-1; i >= 0; i--) {

        digit = A[i] ^ B[i] ^ carry;

        carry = (A[i] & B[i]) | (A[i] & carry) | (B[i] & carry);

        C.push_front(digit);



    }

    C.push_front(carry);

    return C;

}



int numericValue(deque<int> array) {

    int value = 0;

    int digit = 1;

    for (int i = array.size()-1; i >= 0; i--) {

        value += array[i] * digit;

        digit *= 2;

    }

    return value;

}



void printNum(const deque<int>& array, const string& name) {

    cout << name << ": \n";

    for (int elem: array) {

        cout << elem;

    }

    cout << "\n";

}

```



### 2.2 알고리즘의 분석



* 알고리즘&#xC758;*&#x20;분석*은 알고리즘을 실행하는데 필요한 자원 (일반적으로 시간)을 예측하는 것이다.

* RAM (Random Access Machine) 모델: 알고리즘 분석을 위한 추상적인 컴퓨터 모델. RAM 모델에서 명령어는 하나씩 차례대로 시행되며, 메모리는 무한하다 (가상 메모리, 캐시 등은 무시). 일반적으로 산술 연산, 데이터 이동, 제어 연산은 상수 시간이 걸린다.

* 문제마다 입력 크기와 실행 시간을 분석할 필요가 있다.

* 보통 최악의 경우 수행시간만을 분석한다. 그리고 세타 표기법을 이용한다. 이 블로그에서는 입력하기 귀찮아서 O를 세타의 의미로 사용한다.



#### 연습문제



1: 함수 f(n) = n³/1000–100n² …을 점근 표기법으로 나타내라



O(n³)



2: 선택 정렬의 의사코드를 작성하라.



* 의사코드



```

procedure selectionsort(A: a1~an)

  for i = 0 to A.length-2: // n-1개의 항목들을 선택한다

    smallest_index = i

    for j = i+1 to A.length-1:

      if A[smallest_index] > A[j]:

        smallest_index = j

    switch A[i] with A[smallest_index]

```



* C++ 코드



```

#include <iostream>

#include <vector>



using namespace std;



void selectionSort(vector<int>& A);

void printArray(const vector<int>& array);



int main() {

    vector<int> A = {7, 5, 6, 8, 2, 6, 9, 1, 2, 3, 4};

    cout << "Before sort: " << "\n";

    printArray(A);

    selectionSort(A);

    cout << "After sort:" << "\n";

    printArray(A);

}



void selectionSort(vector<int>& A) {

    for (int i = 0; i < A.size()-1; i++) {

        int smallest_index = i;

        for (int j = i+1; j < A.size(); j++) {

            if (A[smallest_index] > A[j]) {

                smallest_index = j;

            }

        }

        int temp = A[i];

        A[i] = A[smallest_index];

        A[smallest_index] = temp;

    }

}



void printArray(const vector<int>& array) {

    for (int elem: array) {

        cout << elem << " ";

    }

    cout << "\n";

}

```



\- 루프 불변성을 설명하고, 왜 n개가 아니라 n-1개만 바꾸면 되는지 설명하라.



이 알고리즘의 루프 불변성은 `A[0]~A[i]가 정렬되어 있다` 이다.



* 초기 조건: i = 0으로 성립

* 유지 조건: 한개를 중간에 더 넣으니 성립.

* 종료 조건: 종료할 때 `i=A.size()-1` 이다. 따라서 배열 전체가 정렬되어 있다.



n-1개만 바꾸면 되는 이유는 k개를 삽입하면 k+1개가 정렬되어 있기 때문이다. 어쨌거나 k+1번째는 앞선 k개보다 크니까



\- 마지막으로 최선/최악 경우 실행시간을 점근 표기법으로 나타내라



* 최선이든 최악이든 계속 검색해서 최소값을 찾아야 하기 때문에 O(n²)



3: 선형 검색을 다시 생각해보자. 배열의 원소를 같은 확률로 검색한다고 가정하면 평균적으로 몇개의 원소를 조사해야 하나? 최악의 경우? 평균/최악 경우 실행시간의 점근 표기법? 증명?



배열 안에 있는 값을 검색하며 배열의 중복이 없다고 가정한다면, 1회\~n-1회 모두 가능하다. 그러면 평균 (n-1)/2개. 최악의 경우 n-1개 (배열에 없는 값을 검색하면 n개)



평균/최악 모두 실행시간 점근 표기법은 O(n)



4: 최선의 경우에 알고리즘이 좋은 수행시간을 갖게 하려면 어떻게 바꿔야 하는가?



* 현재의 경우가 최선의 경우인지 검사해서, 최선의 경우라면 최소한의 연산만을 하도록 바꾼다.

* 연산들을 하기 전에 그 연산들이 불필요한지 검사한다.



### 2.3 알고리즘의 설계



삽입정렬은 점진적인 방법 (Incremental Design)을 사용한다. 다른 설계 방법도 알아보자.



#### 2.3.1 분할정복 접근법 (Divide and Conquer)



* 분할: 현재 문제를 같은 문제를 다루는 부분 문제들로 나눈다.

* 정복: 부분 문제를 재귀적/직접적으로 푼다.

* 결합: 부분 문제의 해를 결합해 원래 문제의 해를 만든다.



병합 정렬 (Merge Sort)는 분할정복의 좋은 예시이다.



* 분할: 배열을 절반 크기의 배열 두개로 분할

* 정복: 분할된 배열을 병합 정렬

* 결합: 정렬된 배열 두개를 결합



병합 정렬에 대해서는 잘 알고 있으니 생략한다.



#### 연습문제



7: n개의 정수의 집합 S와 정수 x가 주어졌을 때, S에 있는 두 원소의 합이 x가 되는 경우가 있는지를 알아내는 O(nlogn) 시간 알고리즘을 작성하라.



* 일단 떠오른 해답:



```

1. S의 원소들을 병합 정렬: O(nlogn)

2. S의 각 원소에 s에 대해 다음을 반복: (n회 반복)

  2-1. s-x를 계산: O(1)

  2-2. s-x를 S에서 이진 탐색: O(logn)

```



2.3장에 있는 것을 보아 분할정복 알고리즘 풀이가 있는 것 같기도?



### 종합문제



By [Woohyuk Jang](https://medium.com/@morrranii) on [February 25, 2023](https://medium.com/p/5f399661c5ba).

Exported from [Medium](https://medium.com) on August 26, 2025.
