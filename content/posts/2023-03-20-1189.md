---
title:  "백준 1189번 컴백홈"
author: "Woohyuk Jang"
draft: false

date: "2023-03-20"
description: ""
categories:
  - CS/PS
tags:
  - Blog
---
### 백준 1189번 컴백홈



[**1189번: 컴백홈**\

*한수는 캠프를 마치고 집에 돌아가려 한다. 한수는 현재 왼쪽 아래점에 있고 집은 오른쪽 위에 있다. 그리고 한수는 집에 돌아가는 방법이 다양하다. 단, 한수는 똑똑하여 한번 지나친 곳을 다시 방문하지는 않는다…*&#x77;ww.acmicpc.net](https://www.acmicpc.net/problem/1189 "https://www.acmicpc.net/problem/1189")[](https://www.acmicpc.net/problem/1189)



\# 풀이



* DFS를 돌면서 depth = k이고 목적지에 도달한 경우의 수를 세면 된다.



\# 태그



* 깊이 우선 탐색/백트래킹

* 브루트포스: 일일히 찾아보니 그런가보다



\# C++ 코드



```

#include <iostream>

#include <vector>



using namespace std;



int path_num;

int r, c, k;



void dfs(const vector<vector<bool>>& map, vector<vector<bool>>& visited, int depth, int current_row, int current_col);



int main() {

    cin >> r >> c >> k;



    path_num = 0;



    vector<vector<bool>> map(r, vector<bool>(c));

    char map_status;

    for (int i = 0; i < r; i++) {

        for (int j = 0; j < c; j++) {

            cin >> map_status;

            map[i][j] = (map_status == '.');

        }

    }



    vector<vector<bool>> visited(r, vector<bool>(c));

    for (int i = 0; i < r; i++) {

        for (int j = 0; j < c; j++) {

            visited[i][j] = false;

        }

    }



    dfs(map, visited, 1, r-1, 0);



    cout << path_num;

}



void dfs(const vector<vector<bool>>& map, vector<vector<bool>>& visited, int depth, int current_row, int current_col) {

    if (depth == k) {

        if (current_row == 0 && current_col == c-1) {

            path_num++;

        }

        return;

    }



    if (current_row == 0 && current_col == c-1) {

        return;

    }



    visited[current_row][current_col] = true;



    vector<pair<int, int>> next_place;

    if (current_row != 0) {

        next_place.emplace_back(current_row-1, current_col);

    }

    if (current_row != r-1) {

        next_place.emplace_back(current_row+1, current_col);

    }

    if (current_col != 0) {

        next_place.emplace_back(current_row, current_col-1);

    }

    if (current_col != c-1) {

        next_place.emplace_back(current_row, current_col+1);

    }



    for (pair<int,int> place: next_place) {

        if (!visited[place.first][place.second] && map[place.first][place.second]) {

            dfs(map, visited, depth+1, place.first, place.second);

            visited[place.first][place.second] = false;

        }

    }

}

```



By [Woohyuk Jang](https://medium.com/@morrranii) on [March 20, 2023](https://medium.com/p/21c82124bd5c).

Exported from [Medium](https://medium.com) on August 26, 2025.
