---
title:  "오라클 DB 16: 저장 서브프로그램"
author: "Woohyuk Jang"
draft: false

date: "2023-02-20"
description: ""
categories:
  - cs/db
tags:
  - Blog
---
### 오라클 DB #16: 저장 서브프로그램



이 글은 [오라클로 배우는 데이터베이스 입문](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171630125) 19장을 읽고 정리한 글이다.



1. 익명 블록 (anonymous block)과 저장 서브프로그램 (stored subprogram)



앞에서 PL/SQL의 기본 단위가 블록이라는 이야기를 했다. 지금까지 써온, 이름이 정해지지 않은 블록은 익명 블록이다. 반면 PL/SQL 프로그램을 이름을 지정하여 오라클에 저장할 수 있는데, 이를 저장 서브프로그램이라 한다.



익명 블록과 달리 서브프로그램은…



* 오라클에 저장된다.

* 저장할 때 한번만 컴파일된다.

* 공유/다른 응용 프로그램에서 호출이 가능하다.



2\. 저장 서브프로그램의 종류



서브 프로그램은 프로시저, 함수, 패키지, 트리 등의 방식으로 저장할 수 있다.



* 저장 프로시저 (stored procedure): 작업 수행. SQL 문에서 사용 불가.

* 저장 함수 (stored function): 값 반환. SQL문에서 사용 가능. (대표적 예로 MAX가 있다)

* 패키지 (package): 저장 서브프로그램을 그룹화.

* 트리거 (trigger): 이벤트 발생에 연달아 기능 수행.



3\. 저장 서브프로그램의 확인



```

-- 저장된 서브프로그램 확인

SELECT NAME, TYPE, LINE, TEXT

FROM USER_SOURCE

WHERE

  NAME = 서브프로그램 이름

  AND TYPE = 타입;

```



저장된 서브프로그램은 USER\_SOURCE 데이터 사전에서 확인 가능하다.



* NAME: 서브프로그램 이름

* TYPE: 서브프로그램 타입 (FUNCTION, PROCEDURE 등)

* LINE: 줄 번호

* TEXT: 소스 코드



```

-- 서브프로그램의 오류 확인

SHOW ERRORS; -- 가장 최근에 생성/변경된 서브프로그램의 오류 정보 출력

SHOW ERRORS PROCEDURE wrong_pro; -- 종류, 이름에 해당하는 서브프로그램 오류 출력

SELECT *

FROM USER_ERRORS

WHERE NAME = 'wrong_pro'; -- 데이터 사전 조회

```



4\. 저장 프로시저 (stored procedure)



```

-- 저장 프로시저 생성/수정

CREATE [OR REPLACE] PROCEDURE 프로시저 이름

[(파라미터 이름1 [modes] 자료형 [:=/DEFAULT 값],

  파라미터 이름2 [modes] 자료형 [:=/DEFAULT 값])]

IS/AS

선언부

BEGIN

실행부

EXCEPTION

예외 처리부

END [프로시저 이름];

```



```

-- 블록에서 저장 프로시저 호출

BEGIN

  저장 프로시저 이름(인자 지정);

END;

```



* 프로시저에 인자(arguments)를 지정하는 방법은 세가지가 있다:



​ ​ ​​​ ​ ​​​ ​ ​​​ ​ ​ ​​​ ​ ​​​ ​ ​​​ ​​- 위치 지정: 순서대로 값 입력 `procedure(arg1, arg2);`



​ ​ ​​​ ​ ​​​ ​ ​​​ ​ ​ ​​​ ​ ​​​ ​ ​​​ ​​- 이름 지정: `procedure(param1 => arg1, param2 => arg2);`



​ ​ ​​​ ​ ​​​ ​ ​​​ ​​ ​ ​​​ ​ ​​​ ​ ​​​ ​- 혼합 지정



* modes에는 IN, OUT, IN OUT을 부여할 수 있다.



​ ​ ​​​ ​ ​​​ ​ ​​​ ​- ​​IN은 프로시저 호출시 값 입력, OUT은 프로시저 호출 후 값 반환.



​ ​ ​​​ ​ ​​​ ​ ​​​ ​- `procedure(param1 => arg1, param2 => arg2, param3 => arg3);` 에서 ​ ​ ​​​ ​ ​​​ ​ ​​​ ​​ ​ ​​​ ​ ​​​ ​ ​​​ ​param1은 IN, param2는 OUT, param3는 IN OUT으로 모드 지정이 되어 ​ ​ ​​​ ​ ​​​ ​ ​​​ ​ 있다면 입력으로 arg1과 arg3가 유의미하고, procedure가 arg2와 arg3에 적​ ​ ​​​ ​ ​​​ ​ ​​​ ​절한 값을 반환한다.



```

-- 프로시저 삭제

DROP PROCEDURE 프로시저 이름;

```



5\. 함수 (function)



* 함수는 프로시저와 달리 다음의 특성을 가지고 있다:



​ ​ ​​​ ​ ​​​ ​ ​​​ ​- SQL문 내에서 직접 실행 가능



​ ​ ​​​ ​ ​​​ ​ ​​​ ​- 파라미터 모드는 IN만 지정



​ ​ ​​​ ​ ​​​ ​ ​​​ ​- RETURN 키워드를 통해 값을 반환



```

-- 함수 생성/수정

CREATE [OR REPLACE] FUNCTION 함수 이름

[(파라미터1 자료형 [:=/DEFAULT 기본값],

  파라미터2 자료형 [:=/DEFAULT 기본값])]

RETURN 자료형

IS/AS

  선언부

BEGIN

  실행부

  RETURN (반환값);

EXCEPTION

  예외 처리부

END;

```



```

-- PL/SQL에서 함수 실행 예시

DECLARE

  randnum NUMBER;

BEGIN

  randnum = random_number(10); -- 반환값을 변수에 저장

END;



-- SQL에서 함수 실행: 마치 내장함수를 쓰듯이

```



```

-- 함수 삭제

DROP FUNCTION func_to_delete;

```



6\. 패키지 (package)



* 여러 PL/SQL 서브프로그램을 하나의 객체로 묶은 것.

* 패키지를 사용할 때의 장점: 모듈성, 쉬운 프로그램 설계, 기능성 향상, 성능 향상.



​ ​ ​​​ ​ ​​​ ​ ​​​ ​- 기능성 향상: 패키지 내에서 커서, 변수 등을 공용으로 사용할 수 있음.



​ ​ ​​​ ​ ​​​ ​ ​​​ ​- 성능 향상: 한번에 메모리에 로딩되어 디스크 I/O 작업 감소



* 패키지는 명세 (specification)과 본문 (body)로 나뉜다.



```

-- 명세 작성/수정

CREATE [OR REPLACE] PACKAGE 패키지이름

IS/AS

  변수, 상수, 예외, 커서, 서브프로그램 등의 다양한 객체 선언.

  이런 객체들은 패키지 외부에서도 사용 가능.



  -- 예시

  variable_example NUMBER := 10;

  FUNCTION func_example(param NUMBER) RETURN NUMBER;

  PROCEDURE proc_example(param IN OUT DATE);

  PROCEDURE proc_example(inparam IN DATE, outparam OUT DATE); -- 오버로딩 가능

END;

```



* 패키지 명세는 DESC 명령어로도 조회할 수 있다.



```

-- 본문 작성/수정

CREATE [OR REPLACE] PACKAGE BODY 패키지이름

IS/AS

  여러 객체의 정의.

  패키지 명세에 존재하지 않는 객체/서브프로그램 정의 가능. 이러한 객체는

  패키지 내부에서만 사용 가능.



  -- 예시

  variable_example NUMBER := 10;

  

  FUNCTION func_example(param NUMBER) RETURN NUMBER

  IS

  BEGIN

    RETURN (param+1);

  END;



  PROCEDURE proc_example(param IN OUT DATE)

  IS

  BEGIN

    param := ADD_MONTHS(param, 10);

  END;



PROCEDURE proc_example(param1 IN DATE, param2 OUT DATE)

  IS

  BEGIN

    param2 := ADD_MONTHS(param1, 10);

  END;



END;

```



```

-- 패키지 이용하기

BEGIN

  package_example.func_example(10); -- 함수/프로시저 이용 예시

END;

```



```

DROP PACKAGE 패키지이름; -- 패키지 명세, 본문 삭제

DROP PACKAGE BODY 패키지이름; -- 패키지 본문만 삭제

```



7\. 트리거 (trigger)



* 이벤트 생성 시 자동으로 실행되는 기능 정의. 데이터베이스 성능 저하의 원인이 될 수 있으므로 주의해야 함.

* 트리거 사용의 장점:



​ ​ ​​​ ​ ​​​ ​ ​​​ ​- 데이터 관련 작업을 간편하게 수행



​ ​ ​​​ ​ ​​​ ​ ​​​ ​- 복잡한 데이터 규칙 -> 수준 높은 데이터 정의



​ ​ ​​​ ​ ​​​ ​ ​​​ ​- 로깅



* 트리거의 종류: DML, DDL, INSTEAD OF, system, simple, compound 트리거 등이 있다. 이 글에서는 DML 트리거만 설명한다.



```

-- DML 문장에 한번 실행하는 트리거

CREATE [OR REPLACE] TRIGGER 트리거 이름

BEFORE/AFTER -- DML 명령 전/후에 트리거 실행

INSERT [OR UPDATE, DELETE] ON 테이블 이름

PL/SQL문;



-- DML 문장의 대상이 되는 행마다 실행하는 트리거

CREATE [OR REPLACE] TRIGGER 트리거 이름

BEFORE/AFTER

INSERT [OR UPDATE, DELETE] ON 테이블 이름

FOR EACH ROW WHEN 조건식

PL/SQL문;

```



```

-- 트리거 정보 조회

SELECT TRIGGER_NAME, TRIGGER_TYPE, TRIGGERING_EVENT, TABLE_NAME, STATUS

FROM USER_TRIGGERS;



-- 트리거 상태 변경

ALTER TRIGGER 트리거이름 ENABLE/DISABLE



-- 특정 테이블 관련 모든 트리거 (비)활성화

ALTER TABLE 테이블이름 ENABLE/DISABLE ALL TRIGGERS;



-- 트리거 삭제

DROP TRIGGER 트리거이름;

```



8\. 참고자료



[**Do it! 오라클로 배우는 데이터베이스 입문**\

*현업 프로그래머이자 강사인 저자가 수많은 프로젝트 경험을 살려 실무에서 진짜 필요한 기본기를 중심으로 내용을 구성했다. 본문 내용은 비전공자도 알기 쉽게 도해와 비유로 풀어 썼고 427개의 예제는 실무에서 ...*&#x77;ww.aladin.co.kr](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171630125 "https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171630125")[](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=171630125)



By [Woohyuk Jang](https://medium.com/@morrranii) on [February 20, 2023](https://medium.com/p/90c179cd68c0).

Exported from [Medium](https://medium.com) on August 26, 2025.
