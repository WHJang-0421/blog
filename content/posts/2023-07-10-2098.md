---
title:  "백준 2098번 외판원 순회"
author: "Woohyuk Jang"
draft: false

date: "2023-07-10"
description: ""
categories:
  - CS/PS
tags:
  - Blog
---
### 백준 2098번 외판원 순회



오랜만이다.



DP\

\- subproblem(i, S): 1에서 i로 S에 속한 원소를 한 번씩 지나 가는 최단경로의 길이 (S는 1 포함, i 미포함)\

\- find min {subproblem(i, total set) + c(i, 1)} over i



\- subproblem(i, S) = min { subproblem(j, S-j) + c(j, i) } over j in S\

\- memoization vs tabulation: tabulation이 낫다.



분석\

\- 공간복잡도 O(n \* 2^n)\

\- 시간복잡도 O(n² \* 2^n)



비트마스킹\

\- 집합 표현: unsigned short 0–65535\

\- 메모리: 65536 \* 16 \* 4 = 4,200,200 byte = 4MB\

\- 집합에 속해 있음: S & j != 0\

\- 집합 S에 j를 추가: S | j\

\- 집합 S에 j를 flip: S ^ j



중간 과정:\

wrong iterative algorithm:\

 start with subproblem(i, S=0) = 0\

 for S = 1 to 65535 (inclusive):\

 for all j:\

 for all i:\

 update subproblem(i, S+j) using subproblem(j, S)



problem: you need to iterate S according to number of elements, not from 1 to 65535



1차 시도:\

iterative algorithm for tabulation:\

 start with subproblem(i, S=0) = 0\

 \

 create queue of S, initialize with 0\

 while queue is not empty:\

 pop S from queue front



for all j not in S:\

 for all i:\

 update subproblem(i, S+j) with subproblem(j, S) if needed \

 push S+j to queue\

 \

 return min {subproblem(i, total set) + c(i, 1)} over i



* 주의할 구현 사항\

   c\[i]\[j] = 0이면 따로 처리\

   c++에서 ^는 거듭제곱이 아니라 bitwise xor임\

   j가 one-hot으로 쓰일 때와 그냥 수로 쓰일 때 구분



이렇게 했는데 아직 안 풀린다. 모듈화된 접근을 하려 한다.



(아직 완성되지 않은) 코드



```

#include <iostream>

#include <queue>

#include <algorithm>

#include <limits>



using namespace std;



int main() {

    short n;

    cin >> n;



    int c[n][n];

    int temp;

    for (short i = 0; i < n; i++) {

        for (short j = 0; j < n; j++) {

            cin >> temp;

            c[i][j] = temp;

        }

    }



    int dp[n][1<<n];

    for (int i = 0; i < n; i++) {

        dp[i][0] = 0;

        for (int j = 1; j < (1<<n); j++) {

            dp[i][j] = numeric_limits<int>::max();

        }

    }



    queue<short> q;

    q.push(1);



    bool visited[1<<n];

    for (int i = 0; i < (1<<n); i++) {

        visited[i] = false;

    }

    visited[0] = true;

    visited[1] = true;

    

    while (!q.empty()) {

        short s = q.front(); // s stands for set

        q.pop();



        for (short j = 1; j < n; j++) {

            if ((s & (1<<j)) == 0) {

                short s_with_j = s | (1<<j);

                for (short i = 0; i < n; i++) {

                    if ((c[j][i] != 0) && ((s & (1<<i)) == 0)) {

                        dp[i][s_with_j] = min(dp[j][s] + c[j][i], dp[i][s_with_j]);

                    }

                }

                if (!visited[s_with_j]) {

                    q.push(s_with_j);

                    visited[s_with_j] = true;

                }

            }

        }

    }



    int result = numeric_limits<int>::max();

    short all = (1<<n)-1;

    for (int i = 1; i < n; i++) {

        if (c[i][0] != 0) {

            result = min(result, dp[i][all^(1<<i)] + c[i][0]);

        }

    }



    cout << result;

}

```



By [Woohyuk Jang](https://medium.com/@morrranii) on [July 10, 2023](https://medium.com/p/2c874e12182).

Exported from [Medium](https://medium.com) on August 26, 2025.
